/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   CGenerator.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jikaewsi <strixz.self@gmail.com>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 01:26:45 by jikaewsi          #+#    #+#             */
/*   Updated: 2025/12/13 01:28:00 by jikaewsi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "CGenerator.hpp"

#include <sstream>
#include <map>

std::string CGenerator::generateHeader(const LexerParser &parser) {

    std::stringstream ss;
    
    ss << "/* Generated by ft_lex */\n";
    ss << "#include <stdio.h>\n";
    ss << "#include <stdlib.h>\n";
    ss << "#include <string.h>\n\n";
    ss << "/* Definitions Section */\n";
    ss << parser.getDefinitions() << "\n\n";
    
    ss << "char *yytext = NULL;\n";
    ss << "int yyleng = 0;\n";
    ss << "int yyin_fd = 0; // Default stdin\n";
    ss << "\n";
    
    return ss.str();

}

std::string CGenerator::generateTables(const DFA &dfa) {
    
    std::stringstream ss;
    ss << "/* DFA Tables */\n";
    
    size_t stateCount = dfa.states.size();
    
    std::map<int, int> idToIndex;
    for (size_t i = 0; i < stateCount; ++i) {
        idToIndex[dfa.states[i]->id] = i;
    }
    
    // Transition Table: C array format
    ss << "static const int yy_nxt[" << stateCount << "][256] = {\n";
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        ss << "    {";
        for (int c = 0; c < 256; ++c) {
            char ch = (char)c;
            int nextIdx = -1;
            if (state->transitions.count(ch)) {
                nextIdx = idToIndex[state->transitions.at(ch)->id];
            }
            ss << nextIdx << ",";
        }
        ss << "},\n";
    }
    
    ss << "};\n\n";

    // Accepting State Table: C array format
    ss << "static const int yy_accept[" << stateCount << "] = {\n    ";
    
    for (size_t i = 0; i < stateCount; ++i) {
        
        auto state = dfa.states[i];
        
        if (state->isAccepting) {
            ss << state->priority << ", ";
        } 
        
        else {
            ss << "-1, ";
        }

    }

    ss << "\n};\n\n";
    return ss.str();

}

// Public interface (calls helper)
std::string CGenerator::generateLexerBody(const LexerParser &parser) {
    return _generateRulesSwitch(parser);
}

// Generates the C switch-case block for rule actions
std::string CGenerator::_generateRulesSwitch(const LexerParser &parser) {
    std::stringstream ss;
    const auto &rules = parser.getRulesList();
    for (size_t i = 0; i < rules.size(); ++i) {
        // C-specific switch/case syntax
        ss << "                case " << i << ":\n";
        ss << "                    " << rules[i].action << "\n";
        ss << "                    break;\n";
    }
    return ss.str();
}

std::string CGenerator::generateUserCode(const LexerParser &parser) {
    std::stringstream ss;
    ss << "\n/* User Code Section */\n";
    ss << parser.getUserCode() << "\n";
    return ss.str();
}
