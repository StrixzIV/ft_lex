/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   CGenerator.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jikaewsi <strixz.self@gmail.com>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 01:26:45 by jikaewsi          #+#    #+#             */
/*   Updated: 2025/12/13 03:20:28 by jikaewsi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "CGenerator.hpp"

#include <sstream>
#include <map>

std::string CGenerator::generateHeader(const LexerParser &parser) {

    std::stringstream ss;
    
    ss << "/* Generated by ft_lex */\n";
    ss << "#include <stdio.h>\n";
    ss << "#include <stdlib.h>\n";
    ss << "#include <string.h>\n";
    ss << "#include <stdint.h>\n\n";
    ss << "/* Definitions Section */\n";
    ss << parser.getDefinitions() << "\n\n";
    
    // Emit start condition defines
    const auto &startConditions = parser.getStartConditions();
    if (!startConditions.empty()) {
        ss << "/* Start Condition Defines */\n";
        ss << "#define INITIAL 0\n";
        int conditionIndex = 1;
        for (const auto &cond : startConditions) {
            ss << "#define " << cond.name << " " << conditionIndex++ << "\n";
        }
        ss << "\n";
    }
    
    return ss.str();

}

std::string CGenerator::generateTables(const DFA &dfa, const LexerParser &parser) {
    
    std::stringstream ss;
    ss << "/* DFA Tables */\n";
    
    size_t stateCount = dfa.states.size();
    
    std::map<int, int> idToIndex;
    for (size_t i = 0; i < stateCount; ++i) {
        idToIndex[dfa.states[i]->id] = i;
    }
    
    // Transition Table: C array format
    ss << "static const int yy_nxt[" << stateCount << "][256] = {\n";
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        ss << "    {";
        for (int c = 0; c < 256; ++c) {
            char ch = (char)c;
            int nextIdx = -1;
            if (state->transitions.count(ch)) {
                nextIdx = idToIndex[state->transitions.at(ch)->id];
            }
            ss << nextIdx << ",";
        }
        ss << "},\n";
    }
    
    ss << "};\n\n";

    // Accepting State Table: C array format
    ss << "static const int yy_accept[" << stateCount << "] = {\n    ";
    
    for (size_t i = 0; i < stateCount; ++i) {
        
        auto state = dfa.states[i];
        
        if (state->isAccepting) {
            ss << state->priority << ", ";
        } 
        
        else {
            ss << "-1, ";
        }

    }

    ss << "\n};\n\n";
    
    // Emit anchor tables
    const auto &rules = parser.getRulesList();
    
    ss << "/* Rule anchor tables */\n";
    ss << "static const int yy_rule_bol[" << rules.size() << "] = {";
    for (size_t i = 0; i < rules.size(); ++i) {
        ss << (rules[i].bolAnchored ? "1" : "0");
        if (i < rules.size() - 1) ss << ", ";
    }
    ss << "};\n";
    
    ss << "static const int yy_rule_eol[" << rules.size() << "] = {";
    for (size_t i = 0; i < rules.size(); ++i) {
        ss << (rules[i].eolAnchored ? "1" : "0");
        if (i < rules.size() - 1) ss << ", ";
    }
    ss << "};\n";
    
    ss << "static int yy_at_bol = 1; /* Start at beginning of line */\n\n";
    
    return ss.str();

}

// Public interface (calls helper)
std::string CGenerator::generateLexerBody(const LexerParser &parser) {
    return _generateRulesSwitch(parser);
}

// Generates the C switch-case block for rule actions
std::string CGenerator::_generateRulesSwitch(const LexerParser &parser) {
    std::stringstream ss;
    const auto &rules = parser.getRulesList();
    for (size_t i = 0; i < rules.size(); ++i) {
        // C-specific switch/case syntax
        ss << "                case " << i << ":\n";
        ss << "                    " << rules[i].action << "\n";
        ss << "                    break;\n";
    }
    return ss.str();
}

std::string CGenerator::generateUserCode(const LexerParser &parser) {
    std::stringstream ss;
    ss << "\n/* User Code Section */\n";
    ss << parser.getUserCode() << "\n";
    return ss.str();
}
