/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   PythonGenerator.cpp                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jikaewsi <strixz.self@gmail.com>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 01:30:45 by jikaewsi          #+#    #+#             */
/*   Updated: 2025/12/13 02:25:54 by jikaewsi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "PythonGenerator.hpp"

#include <sstream>
#include <map>

std::string PythonGenerator::generateHeader(const LexerParser &parser) {

    std::stringstream ss;
    
    ss << "# Generated by ft_lex\n";
    ss << "import sys\n";
    ss << "import re\n\n";
    ss << "# Definitions Section\n";
    ss << parser.getDefinitions() << "\n\n";
    
    ss << "class Token:\n";
    ss << "    def __init__(self, type, text):\n";
    ss << "        self.type = type\n";
    ss << "        self.text = text\n\n";

    return ss.str();

}

std::string PythonGenerator::generateTables(const DFA &dfa) {

    std::stringstream ss;
    
    ss << "    # DFA Tables (Transition and Acceptance)\n";
    
    size_t stateCount = dfa.states.size();
    std::map<int, int> idToIndex;
    
    for (size_t i = 0; i < stateCount; ++i) {
        idToIndex[dfa.states[i]->id] = i;
    }
    
    // Transition Table (Python List of Lists)
    ss << "    YY_NXT = [\n";
    for (size_t i = 0; i < stateCount; ++i) {
    
        auto state = dfa.states[i];
        
        ss << "        [";
        
        for (int c = 0; c < 256; ++c) {
    
            char ch = (char)c;
            int nextIdx = -1;
    
            if (state->transitions.count(ch)) {
                nextIdx = idToIndex[state->transitions.at(ch)->id];
            }
    
            ss << nextIdx;
            if (c < 255) ss << ", ";
    
        }
    
        ss << "]";
        if (i < stateCount - 1) ss << ",";
        ss << "\n";
    
    }
    
    ss << "    ]\n\n";

    // Accepting State Table (Python List)
    ss << "    YY_ACCEPT = [";
    
    for (size_t i = 0; i < stateCount; ++i) {
        
        auto state = dfa.states[i];
        
        if (state->isAccepting) {
            ss << state->priority;
        }
        
        else {
            ss << "-1";
        }

        if (i < stateCount - 1) ss << ", ";

    }
    
    ss << "]\n\n";

    return ss.str();

}

// Generates the Python if/elif block for rule actions
std::string PythonGenerator::generateLexerBody(const LexerParser &parser) {
    std::stringstream ss;
    const auto &rules = parser.getRulesList();
    
    for (size_t i = 0; i < rules.size(); ++i) {
        
        if (i == 0) {
            ss << "                if match_id == " << i << ":\n";
        }
        
        else {
            ss << "                elif match_id == " << i << ":\n";
        }

        std::string action = rules[i].action;
        
        size_t start = action.find_first_not_of(" \t{");
        size_t end = action.find_last_not_of(" \t}");
        
        if (start != std::string::npos && end != std::string::npos) {
            action = action.substr(start, end - start + 1);
        }
        
        // Indent the action with 20 spaces (5 levels * 4 spaces)
        ss << "                    " << action << "\n";
    }
    
    return ss.str();

}

std::string PythonGenerator::generateUserCode(const LexerParser &parser) {
    std::stringstream ss;
    ss << "\n# User Code Section\n";
    ss << parser.getUserCode() << "\n";
    return ss.str();
}
