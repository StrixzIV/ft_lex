/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Generator.cpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jikaewsi <strixz.self@gmail.com>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/11 03:01:45 by jikaewsi          #+#    #+#             */
/*   Updated: 2025/12/11 03:01:45 by jikaewsi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "template.hpp"
#include "Generator.hpp"

#include <map>
#include <string>
#include <sstream>
#include <string_view>

static std::string replace_placeholder(std::string &source, const std::string_view &placeholder, const std::string &replacement) {
    
    std::string::size_type pos = source.find(placeholder.data());
    
    if (pos != std::string::npos) {
        source.replace(pos, placeholder.length(), replacement);
    }
    
    return source;

}


void Generator::generate(const DFA &dfa, const LexerParser &parser, std::ostream &out) {

    // 1. Load the embedded template as a string view (C++17 zero-copy)
    std::string_view template_view(
        reinterpret_cast<const char*>(TEMPLATE_C_START),
        TEMPLATE_C_SIZE
    );
    
    // 2. Copy the template to a mutable string for replacement
    std::string output_code(template_view);

    // 3. Generate dynamic content
    std::string header_code = _generateHeader(parser);
    std::string tables_code = _generateTables(dfa);
    std::string yylex_rules_code = _generateYYLexRules(parser);
    std::string user_code = _generateUserCode(parser);

    // 4. Inject dynamic content into the template placeholders
    replace_placeholder(output_code, "__HEADER_PLACEHOLDER__", header_code);
    replace_placeholder(output_code, "__TABLES_PLACEHOLDER__", tables_code);
    replace_placeholder(output_code, "__YYLEX_RULES_PLACEHOLDER__", yylex_rules_code);
    replace_placeholder(output_code, "__USER_CODE_PLACEHOLDER__", user_code);

    // 5. Write the final code to the output stream
    out << output_code;
    std::cout << output_code;

}

std::string Generator::_generateHeader(const LexerParser &parser) {
    std::stringstream ss;
    ss << "/* Generated by ft_lex */\n";
    ss << "#include <stdio.h>\n";
    ss << "#include <stdlib.h>\n";
    ss << "#include <string.h>\n\n";
    ss << "/* Definitions Section */\n";
    ss << parser.getDefinitions() << "\n\n";
    
    // Standard variables
    ss << "char *yytext = NULL;\n";
    ss << "int yyleng = 0;\n";
    ss << "int yyin_fd = 0; // Default stdin\n";
    ss << "\n";
    return ss.str();
}

std::string Generator::_generateTables(const DFA &dfa) {
    std::stringstream ss;
    ss << "/* DFA Tables */\n";
    
    size_t stateCount = dfa.states.size();
    
    // Transition Table: yy_nxt[state][char]
    ss << "static const int yy_nxt[" << stateCount << "][256] = {\n";
    
    // Map ID -> Index
    std::map<int, int> idToIndex;
    for (size_t i = 0; i < stateCount; ++i) {
        idToIndex[dfa.states[i]->id] = i;
    }
    
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        ss << "    {";
        for (int c = 0; c < 256; ++c) {
            char ch = (char)c;
            int nextIdx = -1;
            if (state->transitions.count(ch)) {
                nextIdx = idToIndex[state->transitions.at(ch)->id];
            }
            ss << nextIdx << ",";
        }
        ss << "},\n";
    }
    ss << "};\n\n";

    // Accepting State Table: yy_accept[state] -> returns priority (rule index) or -1
    ss << "static const int yy_accept[" << stateCount << "] = {\n    ";
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        if (state->isAccepting) {
            ss << state->priority << ", ";
        } else {
            ss << "-1, ";
        }
    }
    ss << "\n};\n\n";
    return ss.str();
}

std::string Generator::_generateYYLexRules(const LexerParser &parser) {
    std::stringstream ss;
    const auto &rules = parser.getRulesList();
    for (size_t i = 0; i < rules.size(); ++i) {
        ss << "                case " << i << ":\n";
        ss << "                    " << rules[i].action << "\n";
        ss << "                    break;\n";
    }
    return ss.str();
}

std::string Generator::_generateUserCode(const LexerParser &parser) {
    std::stringstream ss;
    ss << "\n/* User Code Section */\n";
    ss << parser.getUserCode() << "\n";
    return ss.str();
}
