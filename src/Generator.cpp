/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Generator.cpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jikaewsi <strixz.self@gmail.com>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/11 03:01:45 by jikaewsi          #+#    #+#             */
/*   Updated: 2025/12/11 03:01:45 by jikaewsi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Generator.hpp"
#include <map>

void Generator::generate(const DFA &dfa, const LexerParser &parser, std::ostream &out) {
    _writeHeader(parser, out);
    _writeTables(dfa, out);
    _writeYYLex(dfa, parser, out);
    _writeUserCode(parser, out);
}

void Generator::_writeHeader(const LexerParser &parser, std::ostream &out) {
    out << "/* Generated by ft_lex */\n";
    out << "#include <stdio.h>\n";
    out << "#include <stdlib.h>\n";
    out << "#include <string.h>\n\n";
    out << "/* Definitions Section */\n";
    out << parser.getDefinitions() << "\n\n";
    
    // Standard variables
    out << "char *yytext = NULL;\n";
    out << "int yyleng = 0;\n";
    out << "int yyin_fd = 0; // Default stdin\n";
    out << "\n";
}

void Generator::_writeTables(const DFA &dfa, std::ostream &out) {
    out << "/* DFA Tables */\n";
    
    size_t stateCount = dfa.states.size();
    
    // Transition Table: yy_nxt[state][char]
    out << "static const int yy_nxt[" << stateCount << "][256] = {\n";
    
    // Map ID -> Index
    std::map<int, int> idToIndex;
    for (size_t i = 0; i < stateCount; ++i) {
        idToIndex[dfa.states[i]->id] = i;
    }
    
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        out << "    {";
        for (int c = 0; c < 256; ++c) {
            char ch = (char)c;
            int nextIdx = -1;
            if (state->transitions.count(ch)) {
                nextIdx = idToIndex[state->transitions.at(ch)->id];
            }
            out << nextIdx << ",";
        }
        out << "},\n";
    }
    out << "};\n\n";

    // Accepting State Table: yy_accept[state] -> returns priority (rule index) or -1
    out << "static const int yy_accept[" << stateCount << "] = {\n    ";
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        if (state->isAccepting) {
            out << state->priority << ", ";
        } else {
            out << "-1, ";
        }
    }
    out << "\n};\n\n";
}

void Generator::_writeYYLex(const DFA &dfa, const LexerParser &parser, std::ostream &out) {
    (void) dfa;
    out << "/* yylex Driver */\n";
    out << "int yylex(void) {\n";
    out << "    int current_state;\n";
    out << "    int next_state;\n";
    out << "    int last_accepting_state = -1;\n";
    out << "    char *last_accepting_pos = NULL;\n";
    out << "    char c;\n";
    out << "    \n";
    out << "    // Reset buffer (simplified, assumes full read or line buffered)\n";
    out << "    // For ft_lex simple version, assume stdin reading char by char\n";
    out << "    \n";
    out << "    while (1) {\n";
    out << "        current_state = 0; // Start state assumption (Index 0)\n";
    out << "        last_accepting_state = -1;\n";
    out << "        last_accepting_pos = NULL;\n";
    out << "        \n";
    out << "        // Start accumulating yytext\n";
    out << "        // Note: Real lex has complex buffering. We will use a simple fixed buffer for demo.\n";
    out << "        static char buffer[4096];\n";
    out << "        int buf_idx = 0;\n";
    out << "        int last_accepting_idx = -1;\n";
    out << "        \n";
    out << "        // Check EOF first\n";
    out << "        c = getchar();\n";
    out << "        if (c == EOF) return 0;\n";
    out << "        buffer[buf_idx++] = c;\n";
    out << "        buffer[buf_idx] = 0;\n";
    out << "        \n";
    out << "        // Initial transition\n";
    out << "        next_state = yy_nxt[current_state][(unsigned char)c];\n";
    out << "        \n";
    out << "        while (next_state != -1) {\n";
    out << "            current_state = next_state;\n";
    out << "            if (yy_accept[current_state] != -1) {\n";
    out << "                last_accepting_state = current_state;\n";
    out << "                last_accepting_idx = buf_idx;\n";
    out << "            }\n";
    out << "            \n";
    out << "            c = getchar();\n";
    out << "            if (c == EOF) break;\n";
    out << "            if (buf_idx >= 4095) { fprintf(stderr, \"Buffer overflow\\n\"); exit(1); }\n";
    out << "            buffer[buf_idx++] = c;\n";
    out << "            buffer[buf_idx] = 0;\n";
    out << "            next_state = yy_nxt[current_state][(unsigned char)c];\n";
    out << "        }\n";
    out << "        \n";
    out << "        // No more transitions.\n";
    out << "        if (last_accepting_state != -1) {\n";
    out << "            // Match found!\n";
    out << "            // Backtrack: unwinding characters read past the match\n";
    out << "            \n";
    out << "            // If we hit EOF during search, buf_idx might be greater than last_accepting_idx\n";
    out << "            // If we broke due to invalid transition, we read one char that caused failure (last char in buffer).\n";
    out << "            // But next_state check is done AFTER reading 'c' and looking up table. \n";
    out << "            // The loop structure: Read c -> Add to buf -> Lookup.\n";
    out << "            // If Lookup is -1, loop breaks. 'c' is in buffer. It is NOT part of match (unless current_state was accepting before transition, but we already tracked that).\n";
    out << "            // So characters from last_accepting_idx to buf_idx-1 (inclusive) are excess.\n";
    out << "            \n";
    out << "            while (buf_idx > last_accepting_idx) {\n";
    out << "                ungetc(buffer[--buf_idx], stdin);\n";
    out << "            }\n";
    out << "            buffer[buf_idx] = 0; // Terminate yytext at match end\n";
    out << "            \n";
    out << "            yytext = buffer;\n";
    out << "            yyleng = buf_idx;\n";
    out << "            \n";
    out << "            switch (yy_accept[last_accepting_state]) {\n";
    {
        const auto &rules = parser.getRulesList();
        for (size_t i = 0; i < rules.size(); ++i) {
            out << "                case " << i << ":\n";
            out << "                    " << rules[i].action << "\n";
            out << "                    break;\n";
        }
    }
    out << "            }\n";
    out << "        } else {\n";
    out << "            // No match. Echo char and continue.\n";
    out << "            printf(\"%c\", buffer[0]);\n";
    out << "            // Unput everything else [1..buf_idx-1]\n";
    out << "            while (buf_idx > 1) {\n";
    out << "                ungetc(buffer[--buf_idx], stdin);\n";
    out << "            }\n";
    out << "        }\n";
    out << "    }\n";
    out << "}\n";
}

void Generator::_writeUserCode(const LexerParser &parser, std::ostream &out) {
    out << "\n/* User Code Section */\n";
    out << parser.getUserCode() << "\n";
}
