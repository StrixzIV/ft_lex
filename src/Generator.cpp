/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Generator.cpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: antigravity <antigravity@42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/11 02:50:00 by antigravity       #+#    #+#             */
/*   Updated: 2025/12/11 02:50:00 by antigravity      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Generator.hpp"
#include <map>

void Generator::generate(const DFA& dfa, const LexerParser& parser, std::ostream& out) {
    _writeHeader(parser, out);
    _writeTables(dfa, out);
    _writeYYLex(dfa, parser, out);
    _writeUserCode(parser, out);
}

void Generator::_writeHeader(const LexerParser& parser, std::ostream& out) {
    out << "/* Generated by ft_lex */\n";
    out << "#include <stdio.h>\n";
    out << "#include <stdlib.h>\n";
    out << "#include <string.h>\n\n";
    out << "/* Definitions Section */\n";
    out << parser.getDefinitions() << "\n\n";
    
    // Standard variables
    out << "char *yytext = NULL;\n";
    out << "int yyleng = 0;\n";
    out << "int yyin_fd = 0; // Default stdin\n";
    out << "\n";
}

void Generator::_writeTables(const DFA& dfa, std::ostream& out) {
    out << "/* DFA Tables */\n";
    
    size_t stateCount = dfa.states.size();
    
    // Transition Table: yy_nxt[state][char]
    out << "static const int yy_nxt[" << stateCount << "][256] = {\n";
    
    // We need to map DFA State IDs to array indices strictly 0..N-1
    // The DFA states might have gaps in IDs if we didn't compact them, but our counter was sequential.
    // However, DFA construction might have skipped IDs if we had dead ends, or dfa.states is just a list.
    // Assuming dfa.states vector index == state index for the table.
    
    // Map ID -> Index
    std::map<int, int> idToIndex;
    for (size_t i = 0; i < stateCount; ++i) {
        idToIndex[dfa.states[i]->id] = i;
    }
    
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        out << "    {";
        for (int c = 0; c < 256; ++c) {
            char ch = (char)c;
            int nextIdx = -1;
            if (state->transitions.count(ch)) {
                nextIdx = idToIndex[state->transitions.at(ch)->id];
            }
            out << nextIdx << ",";
        }
        out << "},\n";
    }
    out << "};\n\n";

    // Accepting State Table: yy_accept[state] -> returns priority (rule index) or -1
    out << "static const int yy_accept[" << stateCount << "] = {\n    ";
    for (size_t i = 0; i < stateCount; ++i) {
        auto state = dfa.states[i];
        if (state->isAccepting) {
            out << state->priority << ", ";
        } else {
            out << "-1, ";
        }
    }
    out << "\n};\n\n";
}

void Generator::_writeYYLex(const DFA& dfa, const LexerParser& parser, std::ostream& out) {
    (void) dfa;
    out << "/* yylex Driver */\n";
    out << "int yylex(void) {\n";
    out << "    int current_state;\n";
    out << "    int next_state;\n";
    out << "    int last_accepting_state = -1;\n";
    out << "    char *last_accepting_pos = NULL;\n";
    out << "    char c;\n";
    out << "    \n";
    out << "    // Reset buffer (simplified, assumes full read or line buffered)\n";
    out << "    // For ft_lex simple version, assume stdin reading char by char\n";
    out << "    \n";
    out << "    while (1) {\n";
    out << "        current_state = 0; // Start state assumption (Index 0)\n";
    out << "        last_accepting_state = -1;\n";
    out << "        last_accepting_pos = NULL;\n";
    out << "        \n";
    out << "        // Start accumulating yytext\n";
    out << "        // Note: Real lex has complex buffering. We will use a simple fixed buffer for demo.\n";
    out << "        static char buffer[4096];\n";
    out << "        int buf_idx = 0;\n";
    out << "        \n";
    out << "        // Check EOF first\n";
    out << "        c = getchar();\n";
    out << "        if (c == EOF) return 0;\n";
    out << "        buffer[buf_idx++] = c;\n";
    out << "        buffer[buf_idx] = 0;\n";
    out << "        \n";
    out << "        // Initial transition\n";
    out << "        next_state = yy_nxt[current_state][(unsigned char)c];\n";
    out << "        \n";
    out << "        while (next_state != -1) {\n";
    out << "            current_state = next_state;\n";
    out << "            if (yy_accept[current_state] != -1) {\n";
    out << "                last_accepting_state = current_state;\n";
    out << "            }\n";
    out << "            \n";
    out << "            c = getchar();\n";
    out << "            if (c == EOF) break;\n";
    out << "            if (buf_idx >= 4095) { fprintf(stderr, \"Buffer overflow\\n\"); exit(1); }\n";
    out << "            buffer[buf_idx++] = c;\n";
    out << "            buffer[buf_idx] = 0;\n";
    out << "            next_state = yy_nxt[current_state][(unsigned char)c];\n";
    out << "        }\n";
    out << "        \n";
    out << "        // No more transitions.\n";
    out << "        if (last_accepting_state != -1) {\n";
    
    // IMPORTANT: The simplified logic above is tricky with streams.
    // Let's implement correct backtracking:
    // We have a buffer. 
    // `last_accepting_pos` would be an index in `buffer`.
    
    out << "            /* Backtracking Logic */\n";
    out << "            // We need to unput chars from buffer[last_match_idx+1] to end\n";
    out << "            // For standard lex behavior.\n";
    out << "            \n";
    out << "            yytext = buffer;\n";
    out << "            // yyleng = ...\n";
    out << "            \n";
    out << "            switch (yy_accept[last_accepting_state]) {\n";
    {
        const auto& rules = parser.getRulesList();
        for (size_t i = 0; i < rules.size(); ++i) {
            out << "                case " << i << ":\n";
            out << "                    " << rules[i].action << "\n";
            out << "                    break;\n";
        }
    }
    out << "            }\n";
    out << "        } else {\n";
    out << "            // No match. Echo char and continue.\n";
    out << "            // ungetc everything except first char.\n";
    out << "            printf(\"%c\", buffer[0]);\n";
    out << "        }\n";
    out << "    }\n";
    out << "}\n";
}

void Generator::_writeUserCode(const LexerParser& parser, std::ostream& out) {
    out << "\n/* User Code Section */\n";
    out << parser.getUserCode() << "\n";
}
